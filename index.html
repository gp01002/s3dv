<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI 智能 3D 深度觀賞器</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix"></script>
    <style>
        :root { --accent: #00d2ff; --bg: #0a0a0a; }
        body {
            margin: 0; background: var(--bg); color: white;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; overflow: hidden;
        }
        
        .viewport {
            position: relative; width: 90vw; max-width: 500px;
            perspective: 1200px;
        }
        
        .photo-container {
            position: relative; width: 100%; border-radius: 24px;
            overflow: hidden; background: #111;
            box-shadow: 0 40px 100px rgba(0,0,0,0.7);
            transform-style: preserve-3d;
            transition: transform 0.15s ease-out;
        }

        canvas { width: 100%; display: block; border-radius: 24px; }

        .ui-layer { margin-top: 30px; text-align: center; }
        
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100;
            display: none;
        }

        .btn-group { display: flex; gap: 10px; justify-content: center; }
        .upload-btn {
            background: var(--accent); color: black; padding: 12px 28px;
            border-radius: 50px; cursor: pointer; font-weight: bold;
        }
        input[type="file"] { display: none; }
    </style>
</head>
<body>

    <div id="loading" class="loading-overlay">
        <div style="font-size: 24px; margin-bottom: 10px;">AI 正在掃描人像...</div>
        <div id="status">模型讀取中...</div>
    </div>

    <div class="viewport" id="vbox">
        <div class="photo-container" id="pc">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>

    <div class="ui-layer">
        <div class="btn-group">
            <label class="upload-btn">
                上傳人像照
                <input type="file" id="imgInput" accept="image/*">
            </label>
        </div>
        <p style="color: #666; font-size: 13px; margin-top: 15px;">模型會自動偵測主體並分離背景</p>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading');
        let net, originalImg, foregroundMask;
        let isReady = false;

        // 1. 初始化 AI 模型
        async function initAI() {
            document.getElementById('status').innerText = "載入 BodyPix 模型...";
            loading.style.display = 'flex';
            net = await bodyPix.load({
                architecture: 'MobileNetV1',
                outputStride: 16,
                multiplier: 0.75,
                quantBytes: 2
            });
            loading.style.display = 'none';
        }
        initAI();

        // 2. 處理圖片並進行 AI 分離
        document.getElementById('imgInput').onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            loading.style.display = 'flex';
            document.getElementById('status').innerText = "分析影像深度...";

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = async () => {
                    originalImg = img;
                    // 執行 AI 分離
                    const segmentation = await net.segmentPerson(img);
                    foregroundMask = bodyPix.toMask(segmentation);
                    
                    // 設定畫布尺寸
                    canvas.width = img.width;
                    canvas.height = img.height;
                    isReady = true;
                    loading.style.display = 'none';
                    render(0.5, 0.5);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        };

        // 3. 渲染邏輯：前景與背景分離位移
        function render(px, py) {
            if (!isReady) return;

            const offX = (px - 0.5) * 50; // 背景位移幅度
            const offY = (py - 0.5) * 50;
            const fgX = (px - 0.5) * -15; // 前景反向微動

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 繪製背景層 (稍微放大並偏移)
            ctx.save();
            ctx.filter = 'blur(4px) brightness(0.7)'; // 背景稍微模糊增加深度
            ctx.drawImage(originalImg, -25 + offX, -25 + offY, canvas.width + 50, canvas.height + 50);
            ctx.restore();

            // 繪製前景層 (使用 AI 生成的遮罩)
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tCtx = tempCanvas.getContext('2d');
            
            // 利用遮罩只畫出人像
            tCtx.putImageData(foregroundMask, 0, 0);
            tCtx.globalCompositeOperation = 'source-in';
            tCtx.drawImage(originalImg, 0, 0);

            ctx.drawImage(tempCanvas, fgX, 0, canvas.width, canvas.height);

            // CSS 3D 容器旋轉
            const rotY = (px - 0.5) * 20;
            const rotX = (0.5 - py) * 20;
            document.getElementById('pc').style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg) scale(1.1)`;
        }

        // 互動監聽
        window.onmousemove = (e) => {
            render(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
        };
    </script>
</body>
</html>
