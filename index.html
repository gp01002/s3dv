<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix"></script>

<script>
    // ... 保持你原本的變數宣告 ...
    let bodyPixNet = null; // 新增模型變數
    let foregroundCanvas = null; // 存儲分離出的人像

    // 載入 AI 模型
    async function initAIModel() {
        bodyPixNet = await bodyPix.load();
    }
    initAIModel();

    // === 修改後的 AI 深度模式啟動邏輯 ===
    async function loadAIMode() {
        if (!originalImg) return;
        
        loading.style.display = 'block';
        document.querySelector('#loading div:last-child').innerText = "AI 人像掃描中...";

        // 1. 設定畫布
        const w = originalImg.width;
        const h = originalImg.height;
        cvSingle.width = w;
        cvSingle.height = h;
        pc.style.aspectRatio = `${w}/${h}`;

        // 2. 執行 AI 分離 (如果還沒分離過)
        if (!bodyPixNet) await initAIModel();
        const segmentation = await bodyPixNet.segmentPerson(originalImg);
        
        // 3. 創建離屏畫布存放「人像層」
        foregroundCanvas = document.createElement('canvas');
        foregroundCanvas.width = w;
        foregroundCanvas.height = h;
        const fCtx = foregroundCanvas.getContext('2d');
        
        const mask = bodyPix.toMask(segmentation);
        fCtx.putImageData(mask, 0, 0);
        fCtx.globalCompositeOperation = 'source-in';
        fCtx.drawImage(originalImg, 0, 0);

        loading.style.display = 'none';
        renderAI(0.5, 0.5);
    }

    // === 修改後的 AI 渲染邏輯 (人景分離視差) ===
    function renderAI(percentX, percentY) {
        if (!originalImg || !foregroundCanvas) return;

        const moveX = (percentX - 0.5);
        const moveY = (percentY - 0.5);

        ctxSingle.clearRect(0, 0, cvSingle.width, cvSingle.height);

        // A. 繪製背景層 (位移較大 + 模糊)
        ctxSingle.save();
        ctxSingle.filter = 'blur(5px) brightness(0.8)';
        // 背景稍微放大一點，避免位移時邊緣露白
        const bgShiftX = moveX * 60; 
        const bgShiftY = moveY * 60;
        ctxSingle.drawImage(originalImg, -30 + bgShiftX, -30 + bgShiftY, cvSingle.width + 60, cvSingle.height + 60);
        ctxSingle.restore();

        // B. 繪製人像層 (位移較小或反向位移，產生空間拉開感)
        const fgShiftX = moveX * -15; 
        const fgShiftY = moveY * -15;
        ctxSingle.drawImage(foregroundCanvas, fgShiftX, fgShiftY);

        // C. 保持你原本超棒的容器 3D 旋轉與陰影邏輯
        const rotateY = moveX * 12;
        const rotateX = -moveY * 12;
        pc.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.05)`;
        
        // 這裡可以沿用你原本的動態陰影計算...
        const shadowX = rotateY * 2.5;
        const shadowY = -rotateX * 2.5;
        pc.style.boxShadow = `${shadowX}px ${shadowY}px 50px rgba(0,0,0,0.5), 0 40px 80px rgba(0,0,0,0.8)`;
    }
</script>
